
# Rubyのメモリ管理とガベージコレクション

Rubyは、開発者が手動でメモリの確保や解放を行う必要がない、自動メモリ管理の仕組みを持つ言語です。この中心的な役割を担っているのが**ガベージコレクション (Garbage Collection, GC)** です。Rubyのメモリ管理とGCの基本的な仕組みを理解することは、パフォーマンスの高いアプリケーションを開発し、メモリリークなどの問題を解決する上で役立ちます。

## オブジェクトとメモリ

Rubyでは、数値や文字列、配列など、すべてのデータがオブジェクトとして表現されます。新しいオブジェクトが作成されるたびに、Rubyインタプリタ（YARV）はヒープと呼ばれるメモリ領域にそのオブジェクトのためのスペースを確保します。

```ruby
s = "hello" # "hello"というStringオブジェクトがメモリ上に確保される
a = [1, 2, 3] # 3つのIntegerオブジェクトと、それらを指すArrayオブジェクトが確保される
```

プログラムが実行され、オブジェクトが次々と作られていくと、ヒープ領域は消費されていきます���

## ガベージコレクション (GC) の役割

プログラムの実行が進むと、もはや誰からも参照されなくなったオブジェクトが出てきます。例えば、変数のスコープを抜けた、別の値が代入された、などの理由です。これらの不要になったオブジェクト（ガベージ）がメモリを占有し続けると、いずれメモリ不足に陥ってしまいます。

ガベージコレクションは、このような**どこからも参照されていないオブジェクトを見つけ出し、それらが占有しているメモリを解放して再利用可能にする**ための仕組みです。

## Mark and Sweep (マーク＆スイープ) GC

RubyのGCは、主に**Mark and Sweep（マーク＆スイープ）** と呼ばれるアルゴリズムに基づいています。これは、以下の2つのフェーズで動作します。

### 1. マーク (Mark) フェーズ

- GCは、まず「ルート」と呼ばれるオブジェクト群（グローバル変数、各スレッドのスタックなど、プログラムから直接たどれるオブジェクト）から探索を開始します。
- ルートから参照されているオブジェクトに「生存している（mark）」という印を付けます。
- 次に、印を付けたオブジェクトが���照している先のオブジェクトにも、再帰的に印を付けていきます。
- このプロセスを、生存しているすべてのオブジェクトに印が付くまで繰り返します。

### 2. スイープ (Sweep) フェーズ

- マークフェーズが完了した後、GCはヒープ全体をスキャンします。
- マークフェーズで**印が付かなかった**オブジェクト、つまりどこからも参照されていないオブジェクトを「ガベージ」と判断します。
- これらのガベージオブジェクトが占有していたメモリを解放し、フリーリスト（空きメモリ領域のリスト）に戻して、再利用可能な状態にします。

## 世代別GC (Generational GC)

Ruby 2.1からは、世代別GCが導入され、GCの効率が大幅に向上しました。これは、「ほとんどのオブジェクトは生成後すぐに不要になる」という経験則に基づいています。

- **若い世代 (Young Generation / Minor GC)**: 新しく作成されたオブジェクトは、まず「若い世代」の領域に配置されます。この領域は比較的小さく、頻繁にGC（マイナーGC）が実行されます。多くのオブジェクトはここで回収されます。
- **古い世代 (Old Generation / Major GC)**: マイナーGCを何度か生き延びたオブジェクトは、「長生きする」オブジェクトと見なされ、「古い世代」の領域に移動（promote）されます。古い世代の領域は、若い世代よりもGCの頻度が低く（メジャーGC）、GC全体の停止時間を短縮します。

この仕組みにより、GCは頻繁に死ぬ若いオブジェクトの回収に集中でき、長生きするオブジェクトを毎回スキャンする無駄を省くことができます。

## GCのチューニングと監視

通常、開発者がGCの動作を直接意識する必要はありませんが、大量のオブジェクトを扱うアプリケーションや、パフォーマンスが重要な場面では、GCの挙動を理解し、調整することが有効な場合があります。

### `GC` モジュール

Rubyには、GCを制御・監視するための`GC`モジュールが用意されています。

```ruby
# GCの統計情報を表示
pp GC.stat

# 手動でGCを実行
GC.start

# GCを一時的に無効化
GC.disable
# ... 大量のオブジェクトを一時的に生成する処理 ...
GC.enable
```

`GC.disable`は、ループ内で大量の短命オブジェクトを生成する際などに、ループの途中でGCが走るのを防ぎ、処理時間��短縮できる場合があります��ただし、無効にしている間にメモリを使いすぎないよう注意が必要です。

### 環境変数によるチューニング

Rubyの実行時に環境変数を設定することで、GCの挙動を調整できます。

- `RUBY_GC_HEAP_INIT_SIZE`: 初期ヒープサイズ
- `RUBY_GC_HEAP_GROWTH_FACTOR`: ヒープ拡張係数
- `RUBY_GC_MALLOC_LIMIT`: `malloc`によるメモリ確保量の上限

これらのパラメータを調整することで、アプリケーションのメモリ使用パターンに合わせて、GCの頻度やヒープの拡張戦略を最適化できます。ただし、ほとんどの場合はデフォルト設定で問題なく動作します。

## メモリリークへの注意

Rubyは自動でメモリを管理してくれますが、メモリリークが全く発生しないわけではありません。最も一般的な原因は、**不要になったオブジェクトへの参照が意図せず残り続けてしまう**ことです。

例えば、グローバル変数やクラス変数にオブジェクトを追加し続け、それを削除し忘れるケースです。

```ruby
$global_cache = []

def process_data(data)
  # 処理結果をキャッシュするが、キャッシュをクリアする仕組みがない
  $global_cache << data.process
end
```

こ���ようなコードでは、`$global_cache`が参照を保持し続けるため、キャッシュされたオブジェクトはGCに回収されず、メモリ使用量が増え続けます。

## まとめ

- RubyはGCによる自動メモリ管理を採用しており、開発者は手動でのメモリ解放から解放されます。
- 主要なアルゴリズムは「マーク＆スイープ」で、どこからも参照されていないオブジェクトを回収します。
- 「世代別GC」により、短命なオブジェクトを効率的に回収し、パフォーマンスを向上させています。
- `GC`モジュールや環境変数でGCの挙動を調整できますが、通常は不要です。
- メモリリークは、不要なオブジェクトへの参照が残り続けることで発生するため、長期間生存するオブジェクトの管理には注意が必要です。

GCの基本的な仕組みを理解することは、Rubyアプリケーションのパフォーマンスを深く理解し、メモリ関連の問題に対処するための第一歩です。
