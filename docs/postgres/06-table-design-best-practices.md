---
title: テーブル設計のベストプラクティス
---

# テーブル設計のベストプラクティス

データベースのテーブル設計は、アプリケーションのパフォーマンス、データの整合性、そして将来のメンテナンス性に直接影響を与える、システム開発の根幹をなす工程です。優れた設計はアプリケーションを成功に導き、不適切な設計は将来的に大きな技術的負債となります。

ここでは、堅牢でスケーラブルなデータベースを構築するための、普遍的なベストプラクティスを紹介します。

## 1. 正規化を理解し、適切に適用する

正規化は、データの重複を排除し、データの一貫性を保つための体系的なプロセスです。一般的に、**第3正規形（3NF）**までを目指すことが推奨されます。

*   **第1正規形 (1NF)**: 1つのセルには1つの値しか含まない。
    *   **NG例**: `tags`カラムに`'SQL, PostgreSQL, 設計'`のようにカンマ区切りの文字列を入れる。
    *   **OK例**: `tags`テーブルを別途作成し、中間テーブルで多対多の関係を表現する。

*   **第2正規形 (2NF)**: 複合主キーの一部だけに依存するカラムをなくす。
    *   **例**: `(注文ID, 商品ID)`が主キーのテーブルに`商品名`が含まれている場合、`商品名`は`商品ID`にしか依存しないため2NF違反。`商品`テーブルに分離すべき。

*   **第3正規形 (3NF)**: 主キー以外のカラムに依存するカラムをなくす（推移的依存の排除）。
    *   **例**: `従業員`テーブルに`部署ID`と`部署名`が含まれている場合、`部署名`は`部署ID`に依存するため3NF違反。`部署`テーブルに分離すべき。

**正規化の目的**:
データの冗長性をなくすことで、`INSERT`, `UPDATE`, `DELETE`時に発生する「更新漏れ」や「データ不整合」（更新異常）を防ぎます。

**非正規化の検討**:
正規化を進めるとテーブル数が増え、`JOIN`の回数が増加します。パフォーマンスが非常に重要な場面では、あえて正規化を崩して冗長なデータを持たせる「非正規化」を検討することもありますが、これは明確な意図とトレードオフの理解を持って行うべきです。

## 2. データ型を賢く選択する

カラムに設定するデータ型は、ストレージ効率とデータ整合性の両方に影響します。

*   **適切なサイズを選ぶ**:
    *   `INTEGER`で十分な数値を`BIGINT`にすると、ストレージとメモリを無駄に消費します。
    *   都道府県コードのように固定された値は`SMALLINT`や`ENUM`型（利用可能な場合）が適しています。

*   **文字列型**:
    *   長さが決まっているデータ（例: 国コード 'JP'）には`CHAR(2)`、可変長のデータ（例: ユーザー名）には`VARCHAR(n)`を使用します。
    *   `VARCHAR`の長さ`n`は、アプリケーションの要求と妥当な範囲で設定します。大きすぎると無駄なメモリを確保する可能性があります。

*   **日付と時刻**:
    *   グローバルなサービスでは、タイムゾーン付きの`TIMESTAMPTZ`を標準とすることを強く推奨します。

*   **金額計算**:
    *   浮動小数点数（`FLOAT`, `REAL`）は丸め誤差が発生する可能性があるため、**金額や精密な計算には`NUMERIC`または`DECIMAL`を使用してください**。

## 3. 主キー（Primary Key）の設計

すべてのテーブルには、各行を一意に識別するための主キーを設定すべきです。

*   **サロゲートキー vs ナチュラルキー**:
    *   **サロゲートキー（代理キー）**: `SERIAL`や`UUID`のような、データ自体に意味を持たない一意なID。アプリケーションの変更に強く、一般的に推奨されます。
    *   **ナチュラルキー（自然キー）**: メールアドレスや社員番号など、データ自体が持つ一意な値。ビジネスルールが変更されるとキーも変更する必要があり、扱いが難しい場合があります。

*   **`SERIAL`または`BIGSERIAL`が一般的**:
    多くのケースで、自動連番の整数型が主キーとして最適です。将来的にデータが大規模になる可能性がある場合は`BIGSERIAL`を検討しましょう。

## 4. 命名規則に一貫性を持たせる

一貫した命名規則は、データベースの可読性とメンテナンス性を劇的に向上させます。

*   **スタイル**: `snake_case`（例: `user_profiles`）がSQLの世界では一般的です。
*   **単数形か複数形か**: テーブル名は、それがレコードの集合であることを示す「複数形」（例: `users`）が推奨されることが多いです。カラム名は「単数形」（例: `user_id`）です。どちらを採用するにせよ、プロジェクト内で統一することが最も重要です。
*   **予約語を避ける**: `user`, `order`, `group`など、SQLの予約語をテーブル名やカラム名に使用するのは避けましょう。予期せぬエラーの原因となります。
*   **IDカラムの命名**: 外部キーとして使用する際、どのテーブルを参照しているか明確にするため、`id`ではなく`テーブル名_id`（例: `users`テーブルの主キーは`id`、`posts`テーブルの外部キーは`user_id`）とすることが推奨されます。

## 5. インデックスを効果的に利用する

インデックスは`SELECT`文のパフォーマンスを向上させるための強力なツールですが、`INSERT`や`UPDATE`の性能をわずかに低下させるトレードオフがあります。

*   **インデックスを貼るべきカラム**:
    *   主キー（自動的に作成されます）
    *   外部キー
    *   `WHERE`句で頻繁に検索条件として使われるカラム
    *   `ORDER BY`句で頻繁にソートに使われるカラム

*   **複合インデックス**:
    複数のカラムを`WHERE`句で同時に指定することが多い場合（例: `WHERE last_name = ? AND first_name = ?`）、複合インデックスを作成すると効果的です。カラムの順番が重要になります。

*   **貼りすぎに注意**:
    インデックスはストレージを消費し、書き込み処理のオーバーヘッドとなるため、不要なインデックスは作成しないようにしましょう。

これらのベストプラクティスに従うことで、長期間にわたって健全な状態を保てる、効率的で信頼性の高いデータベースを設計することができます。
