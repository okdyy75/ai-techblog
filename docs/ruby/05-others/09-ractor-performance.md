# Ractorのパフォーマンスと実用例

## はじめに
Ractorは、Ruby 3.0で導入された、真の並列処理を実現するための新しい並行処理モデルです。スレッドセーフを保証しながら、複数のCPUコアを効率的に利用することができます。

## Ractorの概要
Ractorは、スレッドとは異なり、オブジェクトを共有しません。各Ractorは独立したオブジェクト空間を持ち、メッセージパッシングによって通信します。これにより、グローバルVMロック（GVL）に縛られずに、複数のRactorが同時にCPUで実行されることが可能になります。

## パフォーマンス
- **CPUバウンドなタスク:** 計算量の多いタスク（画像のエンコード、科学技術計算など）では、Ractorを使用することでコア数に応じたリニアなパフォーマンス向上が期待できます。
- **I/Oバウンドなタスク:** ネットワーク通信やファイルI/Oが中心のタスクでは、従来のスレッドベースの並行処理でも十分な性能が出ることが多く、Ractorのメリットは限定的かもしれません。

## 実用例
- **Webサーバー:** Puma 5から、Ractorを実験的に利用してリクエストを並列処理する機能が追加されました。
- **データ処理パイプライン:** 大量のデータを複数のステージで処理する際に、各ステージをRactorとして実装することで、スループットを向上させることができます。
- **機械学習の推論:** 複数のリクエストに対して、独立して推論処理を並列実行するケース。

## 注意点
- **オブジェクト共有の制限:** Ractor間で共有できるオブジェクトは、`shareable`（不変）なオブジェクトに限られます。
- **ライブラリの対応:** 多くの既存GemはまだRactorセーフではありません。

## まとめ
Ractorは、Rubyにおける並列処理の未来を担う重要な機能です。まだエコシステムの対応など課題はありますが、CPUをフル活用したいパフォーマンスクリティカルな場面で強力な武器となります。
